let currentFields = [];
let currentRecords = [];
let isFormLoaded = false;
let isLoadingFields = false;

// Initialize
function showSection(sectionId) {
    document.querySelectorAll('.section').forEach(section => {
        section.classList.remove('active');
    });
    document.querySelectorAll('.nav button').forEach(btn => {
        btn.classList.remove('active');
    });
    
    document.getElementById(sectionId).classList.add('active');
    document.getElementById(sectionId + '-btn').classList.add('active');

    if (sectionId === 'view-data') {
        loadRecords();
    } else if (sectionId === 'documents') {
        loadGeneratedDocuments();
    }
}

async function exportToExcel() {
    try {
        const response = await fetch('/api/getRecords');
        const data = await response.json();
        const res = await fetch('/api/download-excel', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', "content-encoding": "gzip" },
            body: pako.gzip(JSON.stringify({projectId: 1, data: data.records}))
        });
        
        if (res.ok) {
            const blob = await res.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'patient_data.xlsx';
            a.click();
            window.URL.revokeObjectURL(url);
            showAlert('Data Downloaded Successfully');
        } else {
            throw new Error('Failed to download records');
        }
    } catch (error) {
        console.error('Error downloading record:', error);
        showAlert('Error downloading record', 'error');
    }
}

async function uploadToS3() {
    try {
        showAlert('Uploading to S3...', 'info');
        
        const response = await fetch('/api/upload-to-s3', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        });
        
        const result = await response.json();
        
        if (response.ok) {
            if (result.uploaded) {
                showAlert(`‚úÖ Successfully uploaded ${result.recordCount} records to S3`, 'success');
            } else {
                showAlert('‚ÑπÔ∏è No new data to upload', 'info');
            }
        } else {
            throw new Error(result.error || 'Failed to upload to S3');
        }
    } catch (error) {
        console.error('Error uploading to S3:', error);
        showAlert('Error uploading to S3: ' + error.message, 'error');
    }
}

// NEW: Load generated documents from S3
async function loadGeneratedDocuments() {
    try {
        showAlert('Loading documents...', 'info');
        
        const response = await fetch('/api/generated-documents');
        const data = await response.json();
        
        if (response.ok) {
            renderDocumentsList(data.documents);
            if (data.documents.length === 0) {
                showAlert('No documents found', 'info');
            } else {
                // Clear alert after successful load
                setTimeout(() => {
                    document.getElementById('alert-container').innerHTML = '';
                }, 1000);
            }
        } else {
            throw new Error(data.error || 'Failed to load documents');
        }
    } catch (error) {
        console.error('Error loading documents:', error);
        showAlert('Error loading documents: ' + error.message, 'error');
    }
}

// FIXED: Render documents list using DOM manipulation
function renderDocumentsList(documents) {
    const container = document.getElementById('documents-list');
    
    if (!documents || documents.length === 0) {
        container.innerHTML = `
            <div class="empty-state">
                <div class="empty-icon">üìÑ</div>
                <h3>No Documents Yet</h3>
                <p>Documents generated by Carbone will appear here after data is uploaded to S3</p>
            </div>
        `;
        return;
    }

    // Clear container first
    container.innerHTML = '';
    
    const grid = document.createElement('div');
    grid.className = 'documents-grid';
    
    documents.forEach(doc => {
        const date = new Date(doc.lastModified).toLocaleString();
        const fileExtension = doc.name.split('.').pop().toUpperCase();
        const icon = getFileIcon(fileExtension);
        
        // Create card
        const card = document.createElement('div');
        card.className = 'document-card';
        
        // Document icon
        const iconDiv = document.createElement('div');
        iconDiv.className = 'document-icon';
        iconDiv.textContent = icon;
        
        // Document info
        const infoDiv = document.createElement('div');
        infoDiv.className = 'document-info';
        
        const nameH4 = document.createElement('h4');
        nameH4.className = 'document-name';
        nameH4.title = doc.name;
        nameH4.textContent = doc.name;
        
        const metaDiv = document.createElement('div');
        metaDiv.className = 'document-meta';
        
        const sizeSpan = document.createElement('span');
        sizeSpan.className = 'document-size';
        sizeSpan.textContent = `üìä ${doc.sizeFormatted}`;
        
        const dateSpan = document.createElement('span');
        dateSpan.className = 'document-date';
        dateSpan.textContent = `üïí ${date}`;
        
        metaDiv.appendChild(sizeSpan);
        metaDiv.appendChild(dateSpan);
        
        infoDiv.appendChild(nameH4);
        infoDiv.appendChild(metaDiv);
        
        // Download button
        const downloadBtn = document.createElement('button');
        downloadBtn.className = 'btn-download';
        downloadBtn.textContent = '‚¨áÔ∏è Download';
        downloadBtn.title = `Download ${doc.name}`;
        downloadBtn.onclick = () => downloadDocument(doc.key);
        
        // Assemble card
        card.appendChild(iconDiv);
        card.appendChild(infoDiv);
        card.appendChild(downloadBtn);
        
        grid.appendChild(card);
    });
    
    container.appendChild(grid);
}

// NEW: Get file icon based on extension
function getFileIcon(extension) {
    const icons = {
        'PDF': 'üìï',
        'DOCX': 'üìò',
        'DOC': 'üìò',
        'XLSX': 'üìó',
        'XLS': 'üìó',
        'CSV': 'üìä',
        'TXT': 'üìÑ',
        'PNG': 'üñºÔ∏è',
        'JPG': 'üñºÔ∏è',
        'JPEG': 'üñºÔ∏è'
    };
    return icons[extension] || 'üìÑ';
}

// NEW: Download document from S3
async function downloadDocument(key) {
    try {
        showAlert('Preparing download...', 'info');
        
        // Use query parameter instead of path parameter
        const encodedKey = encodeURIComponent(key);
        const response = await fetch(`/api/download-document?key=${encodedKey}`);
        const data = await response.json();
        
        if (response.ok && data.url) {
            // Open presigned URL to trigger download
            const a = document.createElement('a');
            a.href = data.url;
            a.target = '_blank';
            const fileName = key.split('/').pop();
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            showAlert('Download started', 'success');
        } else {
            throw new Error(data.error || 'Failed to generate download URL');
        }
    } catch (error) {
        console.error('Error downloading document:', error);
        showAlert('Error downloading document: ' + error.message, 'error');
    }
}

function showAlert(message, type = 'success') {
    const alertContainer = document.getElementById('alert-container');
    alertContainer.innerHTML = `<div class="alert alert-${type}">${message}</div>`;
    setTimeout(() => {
        alertContainer.innerHTML = '';
    }, 5000);
}

async function loadFields() {
    if (isLoadingFields || isFormLoaded) {
        console.log('Fields already loading or loaded, skipping...');
        return;
    }
    
    isLoadingFields = true;
    
    try {
        const response = await fetch('/api/fields');
        const fields = await response.json();
        console.log('Loaded fields:', fields);
        
        const uniqueFields = [];
        fields.forEach(field => {
            uniqueFields.push(field);
        });
        
        console.log('Unique fields after deduplication:', uniqueFields);
        
        currentFields = uniqueFields;
        isFormLoaded = true;
    } catch (error) {
        console.error('Error loading fields:', error);
        showAlert('Error loading form fields', 'error');
    } finally {
        isLoadingFields = false;
    }
}

function scrollToTop(duration = 800) {
    const start = window.scrollY;
    const startTime = performance.now();

    function scrollStep(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const ease = 1 - Math.pow(1 - progress, 3);

        window.scrollTo(0, start * (1 - ease));

        if (progress < 1) {
            requestAnimationFrame(scrollStep);
        }
    }

    requestAnimationFrame(scrollStep);
}

document.getElementById('dataForm').addEventListener('submit', async function(e) {
    e.preventDefault();
    
    const formData = new FormData(e.target);
    const data = {};
    
    for (let [key, value] of formData.entries()) {
        data[key] = value;
    }

    console.log(data);
    
    try {
        const response = await fetch('/api/addDataEntry', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', "content-encoding": "gzip" },
            body: pako.gzip(JSON.stringify({ projectId: 1, data: data }))
        });
        
        if (response.ok) {
            showAlert('Data Entry added Successfully');
            scrollToTop(800);
        } else {
            throw new Error('Failed to save record');
        }
    } catch (error) {
        console.error('Error saving record:', error);
        showAlert('Error saving record', 'error');
    }
});

function clearForm() {
    document.getElementById('dataForm').reset();
}

async function loadRecords() {
    try {
        const response = await fetch('/api/getRecords');
        const data = await response.json();
        console.log(data.records);
        renderRecordsTable(data.records);
    } catch (error) {
        console.error('Error loading records:', error);
        showAlert('Error loading records', 'error');
    }
}

function renderRecordsTable(records) {
    const header = document.getElementById('records-header');
    const body = document.getElementById('records-body');

    if (!records || records.length === 0) {
        header.innerHTML = '<th>No records found</th>';
        body.innerHTML = '';
        return;
    }

    console.log(currentFields);
    const fieldNames = currentFields.map(f => f.label);

    // Create header
    header.innerHTML = '<th>Record ID</th>' + fieldNames.map(name =>
        `<th>${currentFields.find(f => f.label === name)?.label || name}</th>`
    ).join('');

    // Create rows
    let html = ``;

    records.forEach(record => {
        html += '<tr><td>' + record.id + '</td>' +
            fieldNames.map(fn => `<td>${record[fn] || ''}</td>`).join('') +
            '</tr>';
    });

    console.log(html);
    body.innerHTML = html;
}

async function buildForm() {
    const formFieldsDiv = document.getElementById("form-fields");
    formFieldsDiv.innerHTML = "";

    const res = await fetch("/api/fields");
    const fields = await res.json();

    fields.forEach(field => {
        let index = 1;
        const wrapper = document.createElement("div");
        wrapper.classList.add("form-group");
        
        const fieldLabel = field.label;
        const label = document.createElement("label");
        label.setAttribute("for", fieldLabel);

        // If field label contains HTML tags, render safely; otherwise use plain text
        if (/<[a-z][\s\S]*>/i.test(fieldLabel)) {
            label.innerHTML = fieldLabel; // render HTML-formatted label
        } else {
            label.textContent = fieldLabel; // plain text fallback
        }

        field.name = fieldLabel.replace(/<[^>]+>/g, '').trim(); // clean name

        let input = {};
        let dummyValue = "";
        input.id = fieldLabel;
        input.name = fieldLabel;
        
        switch (field.type) {
            case "number":
                if (field.min && field.max) {
                    dummyValue = Math.floor((+field.min + +field.max) / 2); 
                } else {
                    dummyValue = 123;
                }
                break;

            case "date":
                dummyValue = field.default || new Date().toISOString().slice(0, 10);
                break;

            case "email":
                dummyValue = field.default || "test@example.com";
                break;

            case "text":
                if (field.validation === "phone") {
                    dummyValue = "123-456-7890";
                } else if (field.validation === "zip") {
                    dummyValue = "12345";
                } else {
                    dummyValue = field.default || `${field.name}`;
                }
                break;

            case "textarea":
                dummyValue = field.default || `Sample text for ${field.label}`;
                break;

            case "select":
            case "radio":
                break;

            default:
                dummyValue = field.default || `${field.name}`;
        }

        switch (field.type) {
            case "date":
            case "email":
            case "number":
            case "text":
                input = document.createElement("input");
                input.type = field.type;
                input.id = field.name;
                input.name = field.name;
                input.classList.add("form-control");
                if (dummyValue) input.value = dummyValue;
                break;

            case "textarea":
                input = document.createElement("textarea");
                input.id = field.name;
                input.name = field.name;
                input.classList.add("form-control");
                input.value = dummyValue;
                break;

            case "select":
                input = document.createElement("select");
                input.id = field.name;
                input.name = field.name;
                input.classList.add("form-control");
                field.choices.forEach((choice, idx) => {
                    const opt = document.createElement("option");
                    const [val, text] = choice.split(",");
                    opt.value = val.trim();
                    opt.textContent = text ? text.trim() : val;
                    if (idx === 0) opt.selected = true;
                    input.appendChild(opt);
                });
                break;

            case "radio":
                input = document.createElement("div");
                field.choices.forEach((choice, idx) => {
                    const [val, text] = choice.split(",");
                    const radioWrapper = document.createElement("div");
                    radioWrapper.classList.add("radio-option");

                    const radio = document.createElement("input");
                    radio.type = "radio";
                    radio.name = field.name;
                    radio.value = val.trim();
                    if (idx === 0) radio.checked = true;

                    const radioLabel = document.createElement("label");
                    radioLabel.textContent = text ? text.trim() : val;

                    radioWrapper.appendChild(radio);
                    radioWrapper.appendChild(radioLabel);
                    input.appendChild(radioWrapper);
                });
                break;

            default:
                input = document.createElement("input");
                input.type = "text";
                input.id = field.name;
                input.name = field.name;
                input.classList.add("form-control");
                input.value = dummyValue;
        }

        wrapper.appendChild(label);
        wrapper.appendChild(input);

        formFieldsDiv.appendChild(wrapper);
        index++;
    });
}

// Initialize
window.onload = () => {
    buildForm();
    loadFields();
};